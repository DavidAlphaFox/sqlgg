sqlgg: SQL Guided (code) Generator
==================================

Problem
-------

Writing database layer code is usually tedious and error-prone, due to the mix of different
languages. SQL queries constructed dynamically need to bind external data (from application), and
the resulting rowset must be decomposed into application native data. Data crossing these
application-to-database boundaries is what causes troubles. One can factor out all common database
communication code, hide the database under some application-specific abstraction, but one always
needs to manually specify correspondence between SQL query binding slots (or resulting rowset
columns) and code variables. This mapping should be updated manually every time SQL query is
modified.

Solution
--------

SQL parser and code generator which ensures that application code and database queries are in sync.
It analyzes SQL query and determines the set of input parameters (values for INSERT, run-time
substitution parameters) and the set of resulting columns (for SELECT). Then it generates the C++
code which structures input and output values together as function parameters and assigns
corresponding native data types. So basically you provide an SQL query and generator creates a C++
function which takes the set of typed parameters as required to fill slots in a query. Generated
code binds provided parameters into query and executes it. SELECT statements additionally return the
collection of structures with fields representing columns of resulting rowset. The most fruitful
consequence of such approach is that the C++ compiler itself guarantees that SQL query will have all
parameters bound with correct types. So if you modify the query and forget to update the code -- the
compiler will point on erroneous parts.

Example
-------

Queries:

    CREATE TABLE test (id INTEGER PRIMARY KEY AUTOINCREMENT,name TEXT,descr TEXT);
    -- [sqlgg] name=Add
    INSERT INTO test(name,descr) VALUES;
    SELECT name,descr FROM test WHERE name = @name LIMIT @limit;
    SELECT name,z FROM 
      (SELECT name,
              city || @delim || descr as y,
              max(length(city),random(*)) as z 
       FROM test 
       LEFT JOIN (SELECT name AS city FROM test WHERE id=@id))
    WHERE z < @level;

Generated code (with some boilerplate omitted):

    // DO NOT EDIT MANUALLY

    // generated by sqlgg 0.2.0 (3a96042c)

    #pragma once

    template <class Traits>
    struct sqlgg
    {
      // CREATE TABLE test (id INTEGER PRIMARY KEY AUTOINCREMENT,name TEXT,descr TEXT)
    public:
      static bool create_test(typename Traits::connection db)
      {
        return Traits::do_execute(db,_T("CREATE TABLE test (id INTEGER PRIMARY KEY AUTOINCREMENT,name TEXT,descr TEXT)"),typename Traits::no_params());
      }

      // INSERT INTO test(name,descr) VALUES
    private:
      struct params_1;

    public:
      static bool Add(typename Traits::connection db, typename Traits::Text const& name, typename Traits::Text const& descr)
      {
        return Traits::do_execute(db,_T("INSERT INTO test(name,descr) VALUES (?,?)"),params_1(name, descr));
      }

      // SELECT name,descr FROM test WHERE name = @name LIMIT @limit
    private:
      template <class T>
      struct output_2
      {
        static void of_stmt(typename Traits::statement stmt, T& obj)
        {
          Traits::get_column_Text(stmt, 0, obj.name);
          Traits::get_column_Text(stmt, 1, obj.descr);
        }
      }; // struct output_2

    private:
      struct params_2;

    public:
      struct data_2
      {
        typename Traits::Text name;
        typename Traits::Text descr;
      }; // struct data_2

    public:
      template<class T>
      static bool select_2(typename Traits::connection db, T& result, typename Traits::Text const& name, typename Traits::Int const& limit)
      {
        return Traits::do_select(db,result,_T("SELECT name,descr FROM test WHERE name = @name LIMIT @limit"),output_2<typename T::value_type>(),params_2(name, limit));
      }

      // SELECT name,z FROM 
    //   (SELECT name,
    //           city || @delim || descr as y,
    //           max(length(city),random(*)) as z 
    //    FROM test 
    //    LEFT JOIN (SELECT name AS city FROM test WHERE id=@id))
    // WHERE z < @level
    private:
      template <class T>
      struct output_3
      {
        static void of_stmt(typename Traits::statement stmt, T& obj)
        {
          Traits::get_column_Text(stmt, 0, obj.name);
          Traits::get_column_Int(stmt, 1, obj.z);
        }
      }; // struct output_3

    private:
      struct params_3;

    public:
      struct data_3
      {
        typename Traits::Text name;
        typename Traits::Int z;
      }; // struct data_3

    public:
      template<class T>
      static bool select_3(typename Traits::connection db, T& result, typename Traits::Text const& delim, typename Traits::Int const& id, typename Traits::Int const& level)
      {
        return Traits::do_select(db,result,_T("SELECT name,z FROM \
      (SELECT name,\
              city || @delim || descr as y,\
              max(length(city),random(*)) as z \
       FROM test \
       LEFT JOIN (SELECT name AS city FROM test WHERE id=@id))\
    WHERE z < @level"),output_3<typename T::value_type>(),params_3(delim, id, level));
      }

    }; // struct sqlgg

Things to note above:

1. The generated code is parametrized by database-specific class `Traits`. It specifies the
		correspondence between SQL and native types, provides types for database connection and other
		details. `Traits` also implements actual code to execute statements. It should be implemented
		once for every specific database API.
2. The annotation `[sqlgg] name=Add` before the INSERT query specifies the name of the generated
    function. NB: there is no need to write (?,?) after VALUES.
1. `Add()` function takes two data parameters, the values to INSERT into table (`params_1` is the
    boilerplate code to bind these parameters into query).
3. `select_2()` returns data via `result` parameter. Hidden auxiliary class `output_2` is used to
    bind columns of rowset to the fields of `T::value_type`, which should have fields `name` and
    `descr` of type `Traits::Text` (otherwise it will fail to compile). For convenience a structure
    satisfying the requirements for output type is generated alongside the function, `data_2` in
    this particular case, so `std::vector<data_2>` for `result` is fine.
4. The types of parameters for `select_2` were inferred correctly (`limit` is `Int` and `name` is
    `Text`. SQL is not a statically-typed language so the inferred types are based on some
    reasonable assumptions.
5. Statement of arbitrary depth across many tables should be supported.
6. Statements are checked for correctness as far as generator is concerned, so it will detect
		syntax errors, non-existent columns in expressions, mismatched columns in compound statements,
		ambiguous column names etc.

Details
-------

The idea is that the generator should take care only of semantic binding between SQL and code sides,
being as unobtrusive as possible. So the choice of the specific database and API is a programmer's
choice. Similarly, queries to the database are expressed in plain SQL, so that the generator can be
easily plugged in any existing project -- just move all SQL statements used in the code to separate
file and feed it to generator.

Distinguishing feature of **sqlgg** is that it starts off with SQL queries, not object models
or SQL table descriptions.

This is work in progress and there is plenty of room for improvement. For now the status of this
project is **works for me** .  I use it for some simple database-access code with
[sqlite3](http://sqlite.org) engine (using suitable [sqlite3_traits](sqlite3_helper.hpp) helper).
This project was started when I found myself editing existing code with tons of C++ wrappers for SQL
queries, each binding several parameters and decomposing results.

A framework should be a tool to save writing repetitive code, rather than a tool you use to avoid
understanding 'what lies beneath'. <http://c2.com/cgi/wiki?PerniciousIngrownSql>

Try it [online](sql.cgi).

TODO
----

* distinguish predicates and expressions (research)
* choose better names for some common cases (WHERE id = ? etc)
* fix line numbers in error output
* resolve conflicts in grammar, check precedences
* type-inference is too primitive
* detect statements on single tables and group the corresponding generated code in one class
* check names (functions and bindings) for uniqueness
* support/test other SQL engines
* generate code for more languages
* read SQL spec
* type check expressions

----
2009-05-09

<style>
code { font-family: monospace; }
pre { background-color: #eee; border: 1px solid #0f0; }
:not(pre) > code { font-size: 1em; }
</style>
