sqlgg: SQL Guided (code) Generator
==================================

Problem
-------

Writing database layer code is usually tedious and error-prone, due to the mix of different
languages. SQL queries constructed dynamically need to bind external data (from application), and
the resulting rowset must be decomposed into application native data. Data crossing these
application-to-database boundaries is what causes troubles. One can factor out all common database
communication code, hide the database under some application-specific abstraction, but one always
needs to manually specify correspondence between SQL query binding slots (or resulting rowset
columns) and code variables. This mapping should be updated manually every time SQL query is
modified.

Solution
--------

SQL parser and code generator which ensures that application code and database queries are in sync.
It analyzes SQL query and determines the set of input parameters (values for INSERT, run-time
substitution parameters) and the set of resulting columns (for SELECT). Then it generates the
code in host language, matching query input and output to function parameters and return values with
corresponding native data types. So basically you provide an SQL query and generator creates a
function which takes the set of typed parameters as required to fill slots in a query. Generated
code binds provided parameters into query and executes it. SELECT statements additionally return the
collection of structures with fields representing columns of resulting rowset (or pass those
structures to callback-function). The most fruitful consequence of such approach is that
the host language compiler will itself check that functions generated from SQL queries will be
called correctly (i.e. all parameters bound with correct types). So if you modify the query and
forget to update the code -- the compiler will point on erroneous parts.

Complete example
----------------

Suppose we store in the database some monetary relationships among people. We use the following SQL
tables and queries:

	-- @create_person
	CREATE TABLE person (id INTEGER PRIMARY KEY AUTOINCREMENT,name TEXT,surname TEXT);
	-- @add_person
	INSERT INTO person (name,surname) VALUES;

	-- @create_money
	CREATE TABLE money (src INTEGER, dst INTEGER, amount INTEGER);
	-- @add_money
	INSERT INTO money VALUES;

	-- @calc_total
	SELECT name || ' ' || surname AS fullname, SUM(amount) as total FROM person JOIN money ON src = id GROUP BY id;
	-- @list_donors
	SELECT DISTINCT surname FROM person JOIN money ON src = id AND dst = (SELECT id FROM person WHERE surname LIKE @surname);

Generate the binding C++ code (boilerplate omitted, only function prototypes shown):

	// DO NOT EDIT MANUALLY

	// generated by sqlgg 0.2.0 (e47e2ef3)

	#pragma once

	template <class Traits>
	struct sqlgg
	{
		// CREATE TABLE person (id INTEGER PRIMARY KEY AUTOINCREMENT,name TEXT,surname TEXT)
		static bool create_person(typename Traits::connection db);

		// INSERT INTO person (name,surname) VALUES
		static bool add_person(typename Traits::connection db, typename Traits::Text const& name,	typename Traits::Text const& surname);

		// CREATE TABLE money (src INTEGER, dst INTEGER, amount INTEGER)
		static bool create_money(typename Traits::connection db);

		// INSERT INTO money VALUES
		static bool add_money(typename Traits::connection db, typename Traits::Int const& src, typename Traits::Int const& dst, typename Traits::Int const& amount);

		// SELECT name || ' ' || surname AS fullname, SUM(amount) as total FROM person JOIN money ON src = id GROUP BY id
		struct data_4
		{
			typename Traits::Text fullname;
			typename Traits::Int total;
		}; // struct data_4

		template<class T>
		static bool calc_total(typename Traits::connection db, T& result);

		// SELECT DISTINCT surname FROM person JOIN money ON src = id AND dst = (SELECT id FROM person WHERE surname LIKE @surname)
		struct data_5
		{
			typename Traits::Text surname;
		}; // struct data_5

		template<class T>
		static bool list_donors(typename Traits::connection db, T& result, typename Traits::Text const& surname);

	}; // struct sqlgg

Things to note above:

1. The generated code is parametrized by database-specific class `Traits`. It specifies the
		correspondence between SQL and native types, provides types for database connection and other
		details. `Traits` also implements actual code to execute statements. It should be implemented
		once for every specific database API.
2. The annotation `[sqlgg] name=Add` before the INSERT query specifies the name of the generated
    function. NB: there is no need to write (?,?) after VALUES.
1. `Add()` function takes two data parameters, the values to INSERT into table (`params_1` is the
    boilerplate code to bind these parameters into query).
3. `select_2()` returns data via `result` parameter. Hidden auxiliary class `output_2` is used to
    bind columns of rowset to the fields of `T::value_type`, which should have fields `name` and
    `descr` of type `Traits::Text` (otherwise it will fail to compile). For convenience a structure
    satisfying the requirements for output type is generated alongside the function, `data_2` in
    this particular case, so `std::vector<data_2>` for `result` is fine.
4. The types of parameters for `select_2` were inferred correctly (`limit` is `Int` and `name` is
    `Text`. SQL is not a statically-typed language so the inferred types are based on some
    reasonable assumptions.
5. Statement of arbitrary depth across many tables should be supported.
6. Statements are checked for correctness as far as generator is concerned, so it will detect
		syntax errors, non-existent columns in expressions, mismatched columns in compound statements,
		ambiguous column names etc.

Details
-------

The idea is that the generator should take care only of semantic binding between SQL and code sides,
being as unobtrusive as possible. So the choice of the specific database and API is a programmer's
choice. Similarly, queries to the database are expressed in plain SQL, so that the generator can be
easily plugged in any existing project -- just move all SQL statements used in the code to separate
file and feed it to generator.

Distinguishing feature of **sqlgg** is that it starts off with SQL queries, not object models
or SQL table descriptions.

This is work in progress and there is plenty of room for improvement. For now the status of this
project is **works for me** .  I use it for some simple database-access code with
[sqlite3](http://sqlite.org) engine (using suitable [sqlite3_traits](sqlite3_helper.hpp) helper).
This project was started when I found myself editing existing code with tons of C++ wrappers for SQL
queries, each binding several parameters and decomposing results.

For now it can generate C++ and OCaml code. Generated C++ code is parametrized with template class
for database specific code. Generated OCaml code is a functor
`module Sqlgg (T:`[Sqlgg\_traits.M](sqlgg_traits.ml)`)` (sample [sqlgg\_sqlite3](sqlgg_sqlite3.ml) 
for [OCaml-SQLite3][]).

[OCaml-SQLite3]:	http://caml.inria.fr/cgi-bin/hump.en.cgi?contrib=471

A framework should be a tool to save writing repetitive code, rather than a tool you use to avoid
understanding 'what lies beneath'. <http://c2.com/cgi/wiki?PerniciousIngrownSql>

Try it [online](sql.cgi).

TODO
----

* distinguish predicates and expressions (research)
* choose better names for some common cases (WHERE id = ? etc)
* fix line numbers in error output
* resolve conflicts in grammar, check precedences
* type-inference is too primitive
* detect statements on single tables and group the corresponding generated code in one class
* check names (functions and bindings) for uniqueness
* support/test other SQL engines
* generate code for more languages
* read SQL spec
* type check expressions

----
2009-05-16

<style>
code { font-family: monospace; }
pre { background-color: #eee; border: 1px solid #0f0; }
:not(pre) > code { font-size: 1em; }
</style>
