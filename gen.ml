(* C++ code generation *)

open Sql
open Printf
open ExtList
open ExtString
open Operators
open Stmt.Raw

module Cpp =
struct
  type value = string * string
  type t = value list

  let to_string x =
    String.concat ", " (List.map (fun (n,t) -> t ^ " " ^ n) x)

  let inline x = 
    String.concat ", " (List.map (fun (n,t) -> n) x)

  let quote = String.replace_chars (function '\n' -> "\\\n" | c -> String.make 1 c)
end

let (inc_indent,dec_indent,make_indent) = 
  let v = ref 0 in
  (fun () -> v := !v + 2),
  (fun () -> v := !v - 2),
  (fun () -> String.make !v ' ')

let print_indent () = print_string (make_indent ())
let indent s = print_indent (); print_string s
let indent_endline s = print_indent (); print_endline s
let empty_line () = print_newline ()
let output fmt = Printf.kprintf indent_endline fmt
let print fmt = Printf.kprintf print_endline fmt
let quote_comment_inline = String.replace_chars (function '\n' -> "\n// " | c -> String.make 1 c)
let comment fmt = Printf.kprintf (indent_endline & quote_comment_inline & (^) "// ") fmt
let open_curly () = output "{"; inc_indent ()
let close_curly fmt = dec_indent (); indent "}"; print fmt
let start_struct name =
   output "struct %s" name;
   open_curly ()
let end_struct name =
   close_curly "; // struct %s" name;
   empty_line ()
let out_public () = dec_indent(); output "public:"; inc_indent()
let out_private () = dec_indent(); output "private:"; inc_indent()
let in_namespace name f =   
  output "namespace %s" name;
  open_curly ();
  let result = f () in
  close_curly " // namespace %s" name;
  empty_line ();
  result

let generate_header () = 
    output "// DO NOT EDIT MANUALLY";
    output "";
    output "// generated by sql2cpp";
    output "";
    output "#pragma once"; 
    output ""

(*
let ns_name table = table.Table.cpp_name
let item_name _ = "row"
let prefix_name _ = ""
*)

let name_of attr index = 
  match attr.RA.name with
  | "" -> sprintf "_%u" index
  | s -> s

let set_column attr index =
  output "Traits::set_column_%s(stmt, %u, obj.%s);" 
    (Type.to_string attr.RA.domain)
    index
    (name_of attr index)

let get_column attr index =
  output "Traits::get_column_%s(stmt, %u, obj.%s);" 
    (Type.to_string attr.RA.domain)
    index
    (name_of attr (index+1))

let param_type_to_string t = Option.map_default Type.to_string "Any" t

let param_name_to_string id index =
  match id with 
  | Next -> sprintf "_%u" index 
  | Numbered x -> sprintf "_%u" x
  | Named s -> s

let make_name props default = Option.default default (Props.get props "name")
let default_name str index = sprintf "%s_%u" str index

let set_param index param =
  let (id,t) = param in
  output "Traits::set_param_%s(stmt, obj.%s, %u);" 
    (param_type_to_string t)
    (param_name_to_string id index)
    index

let output_scheme_binder index scheme =
  out_private ();
  let name = default_name "output" index in
  output "template <class T>";
  start_struct name;

  output "static void of_stmt(sqlite3_stmt* stmt, T& obj)";
  open_curly ();
  List.iteri (fun index attr -> get_column attr index) scheme;
  close_curly "";

  output "static void to_stmt(sqlite3_stmt* stmt, const T& obj)";
  open_curly ();
  List.iteri (fun index attr -> set_column attr (index + 1)) scheme;
  close_curly "";
  end_struct name;
  name

let output_scheme_binder index scheme =
  match scheme with
  | [] -> "typename Traits::no_output"
  | _ -> output_scheme_binder index scheme

let params_to_values = List.mapi (fun i (n,t) -> param_name_to_string n i, param_type_to_string t)
let make_const_values = List.map (fun (name,t) -> name, sprintf "%s const&" t)

let output_value_defs vals =
  vals >> make_const_values >> List.iter (fun (name,t) -> output "%s %s_;" t name)

let output_value_inits vals = 
  match vals with
  | [] -> ()
  | _ -> 
    output " : %s" 
    (String.concat "," (List.map (fun (name,_) -> sprintf "%s_(%s)" name name) vals))

let output_params_binder index params =
  out_private ();
  let name = default_name "params" index in
  start_struct name;
  let values = params_to_values params in
  output_value_defs values;
  empty_line ();
  output "%s(%s)" name (Cpp.to_string (make_const_values values));
  output_value_inits values;
  open_curly ();
  close_curly "";
  empty_line ();
  output "void set_params(sqlite3_stmt* stmt)";
  open_curly ();
  List.iteri set_param params;
  close_curly "";
  empty_line ();
  end_struct name;
  name

let output_params_binder index params =
  match params with
  | [] -> "typename Traits::no_params"
  | _ -> output_params_binder index params

let generate_select_code index scheme params props =
   let scheme_binder_name = output_scheme_binder index scheme in
   let params_binder_name = output_params_binder index params in
   out_public ();
   output "template<class T>";
   let values = params_to_values params in
   let all_params = Cpp.to_string
     (["db","sqlite3*"; "result","T&"] @ (make_const_values values)) 
   in
   let name = make_name props (default_name "select" index) in
   let sql = Props.get props "sql" >> Option.get >> Cpp.quote in
   output "static bool %s(%s)" name all_params;
   open_curly ();
   output "return Traits::do_select(db,result,_T(\"%s\"),%s(),%s(%s));" 
          sql scheme_binder_name params_binder_name (Cpp.inline (make_const_values values));
   close_curly "";
   empty_line ()

(*
let generate_insert_code columns table index (placeholders,props) sql =
      out_public ();
      let name = make_name props (default_name table "insert" index) in
      output (sprintf "static bool %s(sqlite3* db, const %s& val)" name (item_name table));
      open_curly ();
      output (sprintf "return Traits::do_insert<binder_%s>(db,val,_T(\"%s\"));" (item_name table) sql);
      close_curly "";
      output ""
  *)

(*
let generate_modify_code table cols inputs index props sql =
  (* if there is only one input column - do not require full object as a param *)
  let (cols,inputs) = match cols with
  | [(x,_)] -> [],(x.Sql.Col.name,x.Sql.Col.sqltype)::inputs
  | _ -> cols,inputs
  in
  let params_binder_name = output_params_binder index table cols inputs in
  out_public ();
  let data_params = make_const_params inputs in
  let data_params = (match cols with
    | [] -> data_params
    | _ -> ((sprintf "const %s&" (item_name table)),"val")::data_params)
  in
  let params = Cpp.Params.to_string (("sqlite3*","db") :: data_params) in
  let name = make_name props (default_name table "modify" index) in
  output (sprintf "static int %s(%s)" name params);
  open_curly ();
  output (sprintf "return Traits::do_execute(db,\"%s\",%s(%s));" sql 
      params_binder_name (Cpp.inline data_params));
  close_curly "";
  output ""

let generate_delete_code table inputs index props sql =
  let params_binder_name = output_params_binder index table [] inputs in
  out_public ();
  let data_params = make_const_params inputs in
  let params = Cpp.Params.to_string (("sqlite3*","db") :: data_params) in
  let name = make_name props (default_name table "delete" index) in
  output (sprintf "static int %s(%s)" name params);
  open_curly ();
  output (sprintf "return Traits::do_execute(db,\"%s\",%s(%s));" sql 
      params_binder_name (Cpp.Params.inline data_params));
  close_curly "";
  output ""

let generate_create_code table sql =
  out_public ();
  output (sprintf "static int %screate(sqlite3* db)" (prefix_name table));
  open_curly ();
  output (sprintf "return Traits::do_execute(db,\"%s\",typename Traits::no_params());" sql);
  close_curly "";
  output ""
*)

let generate_code index stmt =
  let ((scheme,params),props) = stmt in
  begin match Props.get props "sql" with
  | Some s -> comment "%s" s
  | None -> ()
  end;
  generate_select_code index scheme params props

let process stmts =
(*
  let generate_code index stmt =
    let (kind,table,props,sql) = stmt in
    match kind with
    | Stmt.Create -> generate_table_code table; 
                     generate_create_code table sql
    | Stmt.Select (outputs,exprs,inputs) -> 
        generate_select_code table inputs outputs index props sql
    | Stmt.Modify (cols,inputs) -> generate_modify_code table cols inputs index props sql
    | Stmt.Delete (inputs) -> generate_delete_code table inputs index props sql
  in
*)
  generate_header ();
  output "template <class Traits>";
  start_struct "sql2cpp";
  List.iteri generate_code stmts;
  end_struct "sql2cpp"
