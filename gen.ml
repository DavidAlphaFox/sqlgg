(* Code generation *)

open Printf
open ExtList
open ExtString
open Operators
open Stmt

let (inc_indent,dec_indent,make_indent) =
  let v = ref 0 in
  (fun () -> v := !v + 2),
  (fun () -> v := !v - 2),
  (fun () -> String.make !v ' ')

let print_indent () = print_string (make_indent ())
let indent s = print_indent (); print_string s
let indent_endline s = print_indent (); print_endline s
let output fmt = kprintf indent_endline fmt
let output_l = List.iter indent_endline
let print fmt = kprintf print_endline fmt

let name_of attr index =
  match attr.RA.name with
  | "" -> sprintf "_%u" index
  | s -> s

let param_name_to_string (name,_) index =
  match name with
  | None -> sprintf "_%u" index
  | Some s -> s

let make_name props default = Option.default default (Props.get props "name")
let default_name str index = sprintf "%s_%u" str index

let choose_name props kind index =
  let name = match kind with
  | Create t -> sprintf "create_%s" t
  | Update t -> sprintf "update_%s_%u" t index
  | Insert (_,t) -> sprintf "insert_%s_%u" t index
  | Delete t -> sprintf "delete_%s_%u" t index
  | Alter t -> sprintf "alter_%s_%u" t index
  | Drop t -> sprintf "drop_%s" t
  | Select   -> sprintf "select_%u" index
  in
  make_name props name

let substitute_params s params f =
  let b = Buffer.create (String.length s) in
  let last = List.fold_left (fun i ((name,(i1,i2)),t) ->
    let prefix = String.slice ~first:i ~last:i1 s in
    Buffer.add_string b prefix;
    Buffer.add_string b (f name t);
    i2) 0 params in
  Buffer.add_string b (String.slice ~first:last s);
  Buffer.contents b

let get_sql stmt =
  let sql = Props.get stmt.props "sql" >> Option.get in
(*   let sql = substitute_params sql stmt.params (fun name t -> "XXX") in *)
  (* fill VALUES *)
  match stmt.kind with
  | Insert (true,_) -> sql ^ " (" ^ (String.concat "," (List.map (fun _ -> "?") stmt.params)) ^ ")"
  | _ -> sql

module type Lang = sig
  type t
  val generate : t -> string -> Stmt.t Enum.t -> unit
  val start : unit -> t
  val comment : t -> ('a,unit,string,unit) format4 -> 'a
  val empty_line : t -> unit
end

module Make(S : Lang) = struct

let time_string () = 
  let module U = Unix in
  let t = U.time () >> U.gmtime in
  sprintf "%04u-%02u-%02uT%02u:%02uZ" (1900 + t.U.tm_year) t.U.tm_mon t.U.tm_mday t.U.tm_hour t.U.tm_min

let generate_header out =
  S.comment out "DO NOT EDIT MANUALLY";
  S.comment out "";
  S.comment out "generated by sqlgg %s on %s" Config.version (time_string ());
  S.comment out "visit http://ygrek.org.ua/p/sqlgg/";
  S.empty_line out

let process name stmts =
  let out = S.start () in
  generate_header out;
  S.generate out name stmts

end

