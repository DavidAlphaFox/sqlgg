(* C++ code generation *)

open Sql
open Printf
open ExtList
open ExtString
open Operators

module Cpp =
struct
  type param = string * string
  type t = param list

  let to_string x =
    String.concat ", " (List.map (fun (t,n) -> t ^ " " ^ n) x)

  let inline x = 
    String.concat ", " (List.map (fun (t,n) -> n) x)
end

let (inc_indent,dec_indent,make_indent) = 
  let v = ref 0 in
  (fun () -> v := !v + 2),
  (fun () -> v := !v - 2),
  (fun () -> String.make !v ' ')

let print_indent () = print_string (make_indent ())
let indent s = print_indent (); print_string s
let indent_endline s = print_indent (); print_endline s
let empty_line () = print_newline ()
let output fmt = Printf.kprintf indent_endline fmt
let print fmt = Printf.kprintf print_endline fmt
let quote_comment_inline = String.replace_chars (function '\n' -> "\n// " | c -> String.make 1 c)
let comment fmt = Printf.kprintf (indent_endline & quote_comment_inline & (^) "// ") fmt
let open_curly () = output "{"; inc_indent ()
let close_curly fmt = dec_indent (); indent "}"; print fmt
let start_struct name =
   output "struct %s" name;
   open_curly ()
let end_struct name =
   close_curly "; // struct %s" name;
   empty_line ()
let out_public () = dec_indent(); output "public:"; inc_indent()
let out_private () = dec_indent(); output "private:"; inc_indent()
let in_namespace name f =   
  output "namespace %s" name;
  open_curly ();
  f ();
  close_curly " // namespace %s" name;
  empty_line ()

let generate_header () = 
    output "// DO NOT EDIT MANUALLY";
    output "";
    output "// generated by sql2cpp";
    output "";
    output "#pragma once"; 
    output ""

(*
let ns_name table = table.Table.cpp_name
let item_name _ = "row"
let prefix_name _ = ""
*)

let set_column attr index =
  output "Traits::set_column_%s(stmt, %u, obj.%s);" 
    (Type.to_string attr.RA.domain)
    index
    attr.RA.name

let get_column attr index =
  output "Traits::get_column_%s(stmt, %u, obj.%s);" 
    (Type.to_string attr.RA.domain)
    index
    attr.RA.name

open Stmt.Raw

let set_param_code param index =
  let (id,t) = param in
  sprintf "Traits::set_param_%s(stmt, obj.%s, %u);" 
    (Option.map_default Type.to_string "Any" t) 
    (match id with 
     | Next -> sprintf "_%u" index 
     | Numbered x -> sprintf "_%u" x
     | Named s -> s)
    index

let output_scheme_binder index scheme =
  let name = sprintf "binder_%u" index in
  output "template <class T>";
  start_struct name;

  output "static void of_stmt(sqlite3_stmt* stmt, T& obj)";
  open_curly ();
  List.iteri (fun index attr -> get_column attr index) scheme;
  close_curly "";

  output "static void to_stmt(sqlite3_stmt* stmt, const T& obj)";
  open_curly ();
  List.iteri (fun index attr -> set_column attr (index + 1)) scheme;
  close_curly "";
  end_struct name;
  name

let output_scheme_binder i s = in_namespace "detail" (fun () -> output_scheme_binder i s)
(*
let generate_table_code table =
  out_public ();
  start_struct (item_name table);
  List.iter 
    (fun col -> output (sprintf "%s %s;" (Col.type_to_cpp_string col) col.Col.cpp_name)) 
    table.Table.cols;
  end_struct (item_name table)

let make_const_params inputs = 
  (List.map (fun (name,t) -> (sprintf "const %s&" (Type.to_cpp_string t)),name) inputs)

let output_extra_param_defs placeholders = 
  List.iter (fun (name,t) -> output (sprintf "const %s& %s_;" (Type.to_cpp_string t) name)) placeholders

let output_extra_params_init names = 
  match names with
  | [] -> ()
  | _ -> output (" : " ^ (String.concat "," (List.map (fun name -> sprintf "%s_(%s)" name name) names)))

let output_params_binder binder_index cols_binder ofs inputs =
  out_private ();
  let name = (sprintf "params_binder_%u" binder_index) in
  start_struct name;
  output_extra_param_defs inputs;
  begin match cols_binder with
  | Some binder -> output (sprintf "const row& obj_;")
  | None -> ()
  end;
  output "";
  let params = (match cols_binder with | Some binder -> [sprintf "const row&","obj"] | None -> []) @ 
               (make_const_params inputs)
  in
  output (sprintf "%s(%s)" name (Cpp.to_string params));
  let names = List.map (fun (name,_) -> name) inputs in
  let names = (match cols_binder with | Some _ -> "obj"::names | None -> names) in
  output_extra_params_init names;
  open_curly ();
  close_curly "";
  output "";
  output (sprintf "void set_params(sqlite3_stmt* stmt)");
  open_curly ();
  begin match cols_binder with
  | Some binder -> output (sprintf "%s::to_stmt(stmt,obj_);" binder)
  | None -> ()
  end;
  List.iteri (fun index param -> output (param_binder_code (index+1+ofs) param)) inputs;
  close_curly "";
  output "";
  end_struct name;
  name

let output_params_binder index table cols inputs =
  let binder_name = (match cols with
                     | [] -> None
                     | _ -> Some (output_scheme_binder table cols index))
  in
  match binder_name,inputs with
  | None,[] -> "typename Traits::no_params"
  | _,_ -> output_params_binder index binder_name (List.length cols) inputs

let make_name props default = 
  match Props.get props "name" with
  | Some v -> v
  | None -> default

let default_name table str index = sprintf "%s%s_%u" (prefix_name table) str index

*)
let generate_select_code index scheme params =
   let scheme_binder_name = output_scheme_binder index scheme in
   ignore (scheme_binder_name);
(*    let params_binder_name = output_params_binder index params in *)
(*
   out_public ();
   output "template<class T>";
   let params = Cpp.Params.to_string
     (["sqlite3*","db"; "T&","result"] @ (make_const_params inputs)) 
   in
   let name = make_name props (default_name table "select" index) in
   output
     (sprintf "static bool %s(%s)" name params);
   open_curly ();
   output 
     (sprintf "return Traits::do_select(db,result,_T(\"%s\"),%s(),%s(%s));" 
              sql binder_name params_binder_name (Cpp.Params.inline (make_const_params inputs)));
   close_curly "";
*)
   output ""
(*
let generate_insert_code columns table index (placeholders,props) sql =
      out_public ();
      let name = make_name props (default_name table "insert" index) in
      output (sprintf "static bool %s(sqlite3* db, const %s& val)" name (item_name table));
      open_curly ();
      output (sprintf "return Traits::do_insert<binder_%s>(db,val,_T(\"%s\"));" (item_name table) sql);
      close_curly "";
      output ""
  *)

(*
let generate_modify_code table cols inputs index props sql =
  (* if there is only one input column - do not require full object as a param *)
  let (cols,inputs) = match cols with
  | [(x,_)] -> [],(x.Sql.Col.name,x.Sql.Col.sqltype)::inputs
  | _ -> cols,inputs
  in
  let params_binder_name = output_params_binder index table cols inputs in
  out_public ();
  let data_params = make_const_params inputs in
  let data_params = (match cols with
    | [] -> data_params
    | _ -> ((sprintf "const %s&" (item_name table)),"val")::data_params)
  in
  let params = Cpp.Params.to_string (("sqlite3*","db") :: data_params) in
  let name = make_name props (default_name table "modify" index) in
  output (sprintf "static int %s(%s)" name params);
  open_curly ();
  output (sprintf "return Traits::do_execute(db,\"%s\",%s(%s));" sql 
      params_binder_name (Cpp.inline data_params));
  close_curly "";
  output ""

let generate_delete_code table inputs index props sql =
  let params_binder_name = output_params_binder index table [] inputs in
  out_public ();
  let data_params = make_const_params inputs in
  let params = Cpp.Params.to_string (("sqlite3*","db") :: data_params) in
  let name = make_name props (default_name table "delete" index) in
  output (sprintf "static int %s(%s)" name params);
  open_curly ();
  output (sprintf "return Traits::do_execute(db,\"%s\",%s(%s));" sql 
      params_binder_name (Cpp.Params.inline data_params));
  close_curly "";
  output ""

let generate_create_code table sql =
  out_public ();
  output (sprintf "static int %screate(sqlite3* db)" (prefix_name table));
  open_curly ();
  output (sprintf "return Traits::do_execute(db,\"%s\",typename Traits::no_params());" sql);
  close_curly "";
  output ""
*)

let generate_code index stmt =
  let ((scheme,params),props) = stmt in
  begin match Props.get props "sql" with
  | Some s -> comment "%s" s
  | None -> ()
  end;
  generate_select_code index scheme params

let process stmts =
(*
  let generate_code index stmt =
    let (kind,table,props,sql) = stmt in
    match kind with
    | Stmt.Create -> generate_table_code table; 
                     generate_create_code table sql
    | Stmt.Select (outputs,exprs,inputs) -> 
        generate_select_code table inputs outputs index props sql
    | Stmt.Modify (cols,inputs) -> generate_modify_code table cols inputs index props sql
    | Stmt.Delete (inputs) -> generate_delete_code table inputs index props sql
  in
*)
  generate_header ();
  output "namespace sql2cpp";
  open_curly ();
  List.iteri generate_code stmts;
  close_curly " // namespace sql2cpp"
