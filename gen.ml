(* $Id$ *)

open Sql
open Printf
open ExtList

module Cpp =
struct
  module Params =
  struct
    type param = string * string
    type t = param list

    let to_string x =
      String.concat ", " (List.map (fun (t,n) -> t ^ " " ^ n) x)

    let inline x = 
      String.concat ", " (List.map (fun (t,n) -> n) x)
  end
end

let indent = ref 0
let output s = print_string (String.make !indent ' '); print_endline s
let out_shr () = indent := !indent + 2
let out_shl () = indent := !indent - 2
let open_curly () = output "{"; out_shr ()
let close_curly s = out_shl (); output ("}" ^ s)
let start_struct name =
   output (sprintf "struct %s" name);
   open_curly ()
let end_struct name =
   close_curly (sprintf "; // struct %s" name);
   output ""
let out_public () = out_shl (); output "public:"; out_shr ()
let out_private () = out_shl (); output "private:"; out_shr ()

let generate_header () = 
    output "// DO NOT EDIT MANUALLY";
    output "";
    output "// generated by sql2cpp";
    output "";
    output "#pragma once"; 
    output ""

let ns_name table = table.Table.cpp_name
let item_name _ = "row"
let prefix_name _ = ""

let binder_code col index =
  sprintf "Traits::bind_column_%s(stmt, %u, obj.%s);" 
    (Col.type_to_string col) 
    index
    col.Col.cpp_name

let param_binder_code index (name,t) =
  sprintf "Traits::bind_param_%s(stmt, %s_, %u);"
    (Type.to_string t) 
    name
    index

let binder_code_to col index =
  if Col.is_primary_key col then
    sprintf "Traits::bind_param_null(stmt, %u);" index
  else
    sprintf "Traits::bind_param_%s(stmt, obj.%s, %u);" 
      (Col.type_to_string col) 
      col.Col.cpp_name
      index

(** naive *)
let output_columns_binder table columns binder_index =
  let name = sprintf "binder_%u" binder_index in
  out_private ();
  start_struct name;
  output (sprintf "typedef %s value_type;" (item_name table));
  output (sprintf "static void of_stmt(sqlite3_stmt* stmt, %s& obj)" (item_name table));
  open_curly ();
  List.iteri
    (fun index (col,tbl) -> assert(tbl=table); output (binder_code col index)) 
    columns;
  close_curly "";
  output (sprintf "static void to_stmt(sqlite3_stmt* stmt, const %s& obj)" (item_name table));
  open_curly ();
  List.iteri
    (fun index (col,tbl) -> assert(tbl=table); output (binder_code_to col (index + 1)))
    columns;
  close_curly "";
  end_struct name;
  name

let generate_table_code table =
  out_public ();
  start_struct (item_name table);
  List.iter 
    (fun col -> output (sprintf "%s %s;" (Col.type_to_cpp_string col) col.Col.cpp_name)) 
    table.Table.cols;
  end_struct (item_name table)

let make_const_params inputs = 
  (List.map (fun (name,t) -> (sprintf "const %s&" (Type.to_cpp_string t)),name) inputs)

let output_extra_param_defs placeholders = 
  List.iter (fun (name,t) -> output (sprintf "const %s& %s_;" (Type.to_cpp_string t) name)) placeholders

let output_extra_params_init names = 
  match names with
  | [] -> ()
  | _ -> output (" : " ^ (String.concat "," (List.map (fun name -> sprintf "%s_(%s)" name name) names)))

let output_params_binder binder_index cols_binder ofs inputs =
  out_private ();
  let name = (sprintf "params_binder_%u" binder_index) in
  start_struct name;
  output_extra_param_defs inputs;
  begin match cols_binder with
  | Some binder -> output (sprintf "const row& obj_;")
  | None -> ()
  end;
  output "";
  let params = (match cols_binder with | Some binder -> [sprintf "const row&","obj"] | None -> []) @ 
               (make_const_params inputs)
  in
  output (sprintf "%s(%s)" name (Cpp.Params.to_string params));
  let names = List.map (fun (name,_) -> name) inputs in
  let names = (match cols_binder with | Some _ -> "obj"::names | None -> names) in
  output_extra_params_init names;
  open_curly ();
  close_curly "";
  output "";
  output (sprintf "void set_params(sqlite3_stmt* stmt)");
  open_curly ();
  begin match cols_binder with
  | Some binder -> output (sprintf "%s::to_stmt(stmt,obj_);" binder)
  | None -> ()
  end;
  List.iteri (fun index param -> output (param_binder_code (index+1+ofs) param)) inputs;
  close_curly "";
  output "";
  end_struct name;
  name

let make_params_binder index table cols inputs =
  let binder_name = (match cols with
                     | [] -> None
                     | _ -> Some (output_columns_binder table cols index))
  in
  match binder_name,inputs with
  | None,[] -> "typename Traits::no_params"
  | _,_ -> output_params_binder index binder_name (List.length cols) inputs

let make_name props default = 
  match Props.get props "name" with
  | Some v -> v
  | None -> default

let default_name table str index = sprintf "%s%s_%u" (prefix_name table) str index

let generate_select_code table inputs outputs index props sql =
   let binder_name = output_columns_binder table outputs index in
   let params_binder_name = make_params_binder index table [] inputs in
   out_public ();
   output "template<class T>";
   let params = Cpp.Params.to_string
     (["sqlite3*","db"; "T&","result"] @ (make_const_params inputs)) 
   in
   let name = make_name props (default_name table "select" index) in
   output
     (sprintf "static bool %s(%s)" name params);
   open_curly ();
   output 
     (sprintf "return Traits::do_select(db,result,_T(\"%s\"),%s(),%s(%s));" 
              sql binder_name params_binder_name (Cpp.Params.inline (make_const_params inputs)));
   close_curly "";
   output ""
(*
let generate_insert_code columns table index (placeholders,props) sql =
      out_public ();
      let name = make_name props (default_name table "insert" index) in
      output (sprintf "static bool %s(sqlite3* db, const %s& val)" name (item_name table));
      open_curly ();
      output (sprintf "return Traits::do_insert<binder_%s>(db,val,_T(\"%s\"));" (item_name table) sql);
      close_curly "";
      output ""
  *)

let generate_modify_code table cols inputs index props sql =
  (* if there is only one input column - do not require full object as a param *)
  let (cols,inputs) = match cols with
  | [(x,_)] -> [],(x.Sql.Col.name,x.Sql.Col.sqltype)::inputs
  | _ -> cols,inputs
  in
  let params_binder_name = make_params_binder index table cols inputs in
  out_public ();
  let data_params = make_const_params inputs in
  let data_params = (match cols with
    | [] -> data_params
    | _ -> ((sprintf "const %s&" (item_name table)),"val")::data_params)
  in
  let params = Cpp.Params.to_string (("sqlite3*","db") :: data_params) in
  let name = make_name props (default_name table "modify" index) in
  output (sprintf "static int %s(%s)" name params);
  open_curly ();
  output (sprintf "return Traits::do_execute(db,\"%s\",%s(%s));" sql 
      params_binder_name (Cpp.Params.inline data_params));
  close_curly "";
  output ""

let generate_delete_code table inputs index props sql =
  let params_binder_name = make_params_binder index table [] inputs in
  out_public ();
  let data_params = make_const_params inputs in
  let params = Cpp.Params.to_string (("sqlite3*","db") :: data_params) in
  let name = make_name props (default_name table "delete" index) in
  output (sprintf "static int %s(%s)" name params);
  open_curly ();
  output (sprintf "return Traits::do_execute(db,\"%s\",%s(%s));" sql 
      params_binder_name (Cpp.Params.inline data_params));
  close_curly "";
  output ""

let generate_create_code table sql =
  out_public ();
  output (sprintf "static int %screate(sqlite3* db)" (prefix_name table));
  open_curly ();
  output (sprintf "return Traits::do_execute(db,\"%s\",typename Traits::no_params());" sql);
  close_curly "";
  output ""

let process stmts =
  generate_header ();
  let generate_code index stmt =
    let (kind,table,props,sql) = stmt in
    match kind with
    | Stmt.Create -> generate_table_code table; 
                     generate_create_code table sql
    | Stmt.Select (outputs,exprs,inputs) -> 
        generate_select_code table inputs outputs index props sql
    | Stmt.Modify (cols,inputs) -> generate_modify_code table cols inputs index props sql
    | Stmt.Delete (inputs) -> generate_delete_code table inputs index props sql
  in
  let rec do_process stmts =
    match stmts with
    | [] -> ()
    | (_,t,_,_)::_ ->
        let (some, other) = List.partition (fun (_,table,_,_) -> table = t) stmts in
        output "template<class Traits>";
        start_struct (ns_name t);
        List.iteri generate_code some;
        end_struct (ns_name t);
        do_process other
  in
    output "namespace sql2cpp";
    open_curly ();
    do_process stmts;
    close_curly " // namespace sql2cpp"
